# Vue.js是什么?
	1). 一位华裔前Google工程师(尤雨溪)开发的前端js库
	2). 作用: 动态构建用户界面
	3). 特点:
		* 遵循MVVM模式
		* 编码简洁, 体积小, 运行效率高, 移动/PC端开发
		* 它本身只关注UI, 可以轻松引入vue插件和其它第三库开发项目
	4). 与其它框架的关联:
		* 借鉴angular的模板和数据绑定技术
		* 借鉴react的组件化和虚拟DOM技术
	5). vue包含一系列的扩展插件(库):
		* vue-cli: vue脚手架
		* vue-resource(axios): ajax请求
		* vue-router: 路由
		* vuex: 状态管理
		* vue-lazyload: 图片懒加载
		* vue-scroller: 页面滑动相关
		* mint-ui: 基于vue的组件库(移动端)
		* element-ui: 基于vue的组件库(PC端)
  
  

# 基本使用
    1). 引入vue.js
    2). 创建Vue实例对象(vm), 指定选项(配置)对象
        el : 指定dom标签容器的选择器
        data : 指定初始化状态数据的对象/函数(返回一个对象)
    3). 在页面模板中使用{{}}或vue指令
			

#组件化编程
#### 1. Vue的3大部分  template script style 
```
<template>
    <div></div>      template静态html
</template>
```
```
<script>
    export default {
      props: []/{}
      data(){},
      computed: {}
      methods: {},              JS逻辑处理
      watch: {}
      filters: {}
      directives: {}
      components: {}
    }
</script>
```
```
<style></style>           样式文件
```
#### 2. 组件化编码的基本流程
   	1. 拆分界面, 抽取组件
    2. 编写静态组件
    3. 编写动态组件
        初始化数据, 动态显示初始化界面
        实现与用户交互功能 
    
    
    

# 数据代理
#### 通过一个对象代理对另一个对象中属性的操作(读/写)
#### 通过vm对象来代理data对象中所有属性的操作
#### 好处: 更方便的操作data中的数据
#### 基本实现流程
    1). 通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符
    2). 所有添加的属性都包含getter/setter
    3). 在getter/setter内部去操作data中对应的属性数据    

# 模板解析(compile.js)
#### 1. 模板解析的关键对象: compile对象
#### 2. 模板解析的基本流程:
    1). 将el的所有子节点取出, 添加到一个新建的文档fragment对象中
    2). 对fragment中的所有层次子节点递归进行编译解析处理
        * 对表达式文本节点进行解析
        * 对元素节点的指令属性进行解析
            * 事件指令解析
            * 一般指令解析
    3). 将解析后的fragment添加到el中显示
#### 3. 解析表达式文本节点: textNode.textContent = value
    1). 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1
    2). 从data中取出表达式对应的属性值
    3). 将属性值设置为文本节点的textContent
#### 4. 事件指令解析: elementNode.addEventListener(事件名, 回调函数.bind(vm))
    v-on:click="test"
    1). 从指令名中取出事件名
    2). 根据指令的值(表达式)从methods中得到对应的事件处理函数对象
    3). 给当前元素节点绑定指定事件名和回调函数的dom事件监听
    4). 指令解析完后, 移除此指令属性
#### 5.一般指令解析: elementNode.xxx = value
    1). 得到指令名和指令值(表达式)
    2). 从data中根据表达式得到对应的值
    3). 根据指令名确定需要操作元素节点的什么属性
        * v-text---textContent属性
        * v-html---innerHTML属性
        * v-class--className属性
    4). 将得到的表达式的值设置到对应的属性上
    5). 移除元素的指令属性    

# 数据劫持-->数据绑定
#### 1. 数据绑定(model==>View):
    一旦更新了data中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会更新
#### 2. 数据劫持
    1). 数据劫持是vue中用来实现数据绑定的一种技术
    2). 基本思想: 通过defineProperty()来监视data中所有属性(任意层次)数据的变化, 一旦变化就去更新界面
#### 3. 四个重要对象
    1). Observer（观察者）
        * 用来对data所有属性数据进行劫持的构造函数
        * 给data中所有属性重新定义属性描述(get/set)
        * 为data中的每个属性创建对应的dep对象
    2). Dep(Depend)（依赖）
        * data中的每个属性(所有层次)都对应一个dep对象
        * 创建的时机:
            * 在初始化define data中各个属性时创建对应的dep对象
            * 在data中的某个属性值被设置为新的对象时
        * 对象的结构
            {
              id, // 每个dep都有一个唯一的id
              subs //包含n个对应watcher的数组(subscribes的简写)
            }
        * subs属性说明
            * 当一个watcher被创建时, 内部会将当前watcher对象添加到对应的dep对象的subs中
            * 当此data属性的值发生改变时, 所有subs中的watcher都会收到更新的通知, 从而最终更新对应的界面
    3). Compile
        * 用来解析模板页面的对象的构造函数(一个实例)
        * 利用compile对象解析模板页面
        * 每解析一个表达式(非事件指令)都会创建一个对应的watcher对象, 并建立watcher与dep的关系
        * complie与watcher关系: 一对多的关系
    4). Watcher
        * 模板中每个非事件指令或表达式都对应一个watcher对象
        * 监视当前表达式数据的变化
        * 创建的时机: 在初始化编译模板时
        * 对象的组成
            {
              vm,  //vm对象
              exp, //对应指令的表达式
              cb, //当表达式所对应的数据发生改变的回调函数
              value, //表达式当前的值
              depIds //表达式中各级属性所对应的dep对象的集合对象
                      //属性名为dep的id, 属性值为dep
            }
			
    5). 总结: dep与watcher的关系: 多对多
        * 一个data中的属性对应对应一个dep, 一个dep中可能包含多个watcher(模板中有几个表达式使用到了属性)
        * 模板中一个非事件表达式对应一个watcher, 一个watcher中可能包含多个dep(表达式中包含了几个data属性)
        * 数据绑定使用到2个核心技术
            * defineProperty()
            * 消息订阅与发布
	
#### 4. 双向数据绑定
    1). 双向数据绑定是建立在单向数据绑定(model==>View)的基础之上的
    2). 双向数据绑定的实现流程:
        * 在解析v-model指令时, 给当前元素添加input监听
        * 当input的value发生改变时, 将最新的值赋值给当前表达式所对应的data属性
    

# Vue对象的选项
## 1). el
	指定dom标签容器的选择器
	Vue就会管理对应的标签及其子标签

## 2). data
	对象或函数类型
	指定初始化状态属性数据的对象
	vm也会自动拥有data中所有属性
	页面中可以直接访问使用
	数据代理: 由vm对象来代理对data中所有属性的操作(读/写)
## 3). methods
	包含多个方法的对象
	供页面中的事件指令来绑定回调
	回调函数默认有event参数, 但也可以指定自己的参数
	所有的方法由vue对象来调用, 访问data中的属性直接使用this.xxx

## 4). computed：计算属性
	包含多个方法的对象
	对状态属性进行计算返回一个新的数据, 供页面获取显示
	一般情况下是相当于是一个只读的属性（不可以在计算属性里面操作 this.name=‘XXX’）
	利用set/get方法来实现属性数据的计算读取, 同时监视属性数据的变化
	如何给对象定义get/set属性
		在创建对象时指定: get name () {return xxx} / set name (value) {}
	  	对象创建之后指定: Object.defineProperty(obj, age, {get(){}, set(value){}})
###### 计算属性computed与methods的区别	  	
    computed 与methods实现的效果一样，但是computed会存在缓存
    computed：是基于它的依赖缓存，只有相关的依赖缓存发生变化时，才会重新取值
    什么时候执行computed计算属性：一是初始化显示，二是相关的data属性数据发生变化
    computed计算属性里面的回调函数的函数名 不是data里面已经存在的属性名，要重新命名，并调用
    methods:在重新渲染的时候，函数总会调用执行
    计算属性存在缓存，多次读取值执行一次getter计算
    
###### 计算属性里的get和set
    //计算属性FullName3（双向） 是一个对象
    FullName3: {
        //回调函数：当需要读取当前属性值时回调，计算并返回当前属性的值
        get() {
            return this.firstName + ' ' + this.lastName;
        },
        //回调函数：当属性值FullName3发生变化时回调，更新相关属性数据（firstName lastName）
        set(value) {
            //value就是fullName3的最新输入值
            this.firstName=value.split(' ')[0];
            this.lastName=value.split(' ')[1];
        }
    }    	       	

## 5). watch：通过watch来监听属性的变化
    监听属性里面的回调函数的函数名是data里面已经存在的属性名
	包含多个属性监视的对象
	分为一般监视和深度监视
	    xxx: function(value){}
		xxx : {
			deep : true,
			handler : fun(value)
		}
	另一种添加监视方式: vm.$watch('xxx', function(value){})    

# 编译sass文件 安装下载sass依赖包
    cnpm install --save-dev node-sass sass-loader	

# 事件修饰符
#### 参考：https://blog.csdn.net/a250758092/article/details/78354319
    <a @click.stop="doThis"></a>
    @click.stop:阻止单击事件冒泡
    @click.prevent:提交事件不再重载页面
    @click.capture:添加事件着呢侦听器时使用事件捕捉模式
    @click.self:只当事件在该元素本身（不作用于子元素）触发时触发回调
    @click.once:click事件只能点击一次
    @submit.prevent提交事件不再重载页面（一般用于表单）

# 按修饰符：监听键盘事件时的修饰符
#### <input v-on:keyup.enter='submit'>  简写： <input @keyup.enter='submit'>
#### 常见按键修饰符如下：
     .enter  .tab  .delete  .esc  .space  .up  .down  .left  .right  .ctrl  .alt  .shift  .meta

# MVVM模式
    M:model 模型 （就是data）
    V:view 视图 (Dom)
    VM:ViewModel 视图模型 （new Vue的实例对象）

# 项目的打包与发布
#### 1. 打包:会自动打包，并生成dist目录文件
    cnpm run build

#### 2. 发布方法一：（使用静态服务器工具包）
    cnpm install -g serve
    serve dist
    访问：http://localhost:8080

#### 3. 发布方法二：（使用动态web服务器tomcat）
    * 修改配置文件 webpack.prod.conf.js
        output{
           publicPath:'XXX'  XXX是打包目录的名称
        } 
    * 重新打包 cnpm run build
    * 修改dist文件夹为项目名称 XXX
    * 将XXX 拷贝到运行的tomcat的webapps目录下面
    * 访问：http://localhost:8080/XXX/          